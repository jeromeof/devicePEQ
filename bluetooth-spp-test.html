<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bluetooth SPP Device Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      padding: 20px;
    }
    .container {
      border: 1px solid #ccc;
      padding: 15px;
      max-width: 800px;
      margin-bottom: 20px;
      background-color: #f9f9f9;
    }
    .controls {
      margin-top: 10px;
    }
    button {
      margin: 5px;
      padding: 8px 15px;
      cursor: pointer;
      background-color: #007cba;
      color: white;
      border: none;
      border-radius: 4px;
    }
    button:hover {
      background-color: #005a87;
    }
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .log {
      font-size: 0.9em;
      color: #333;
      background: #eee;
      padding: 10px;
      max-width: 800px;
      white-space: pre-wrap;
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #ddd;
    }
    .status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
    }
    .status.connected {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .status.disconnected {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .device-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin: 10px 0;
    }
    .info-item {
      background: white;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .info-label {
      font-weight: bold;
      color: #555;
    }
  </style>
</head>
<body>

<h2>Bluetooth SPP Device Communication Test</h2>

<div class="container">
  <h3>Connection</h3>
  <div id="status" class="status disconnected">Disconnected</div>
  <div class="controls">
    <button onclick="connectSPP()" id="connectBtn">Connect Bluetooth SPP Device</button>
    <button onclick="updateBudsInfo()" id="autoReconnectBtn">Auto-Reconnect</button>
    <button onclick="disconnectDevice()" id="disconnectBtn" disabled>Disconnect</button>
    <button onclick="initDevice()" id="initBtn" disabled>Initialize Device</button>
  </div>
</div>

<div class="container">
  <h3>Device Information</h3>
  <div class="device-info">
    <div class="info-item">
      <div class="info-label">Firmware Version:</div>
      <div id="firmwareVersion">-</div>
    </div>
    <div class="info-item">
      <div class="info-label">Model Base:</div>
      <div id="modelBase">-</div>
    </div>
    <div class="info-item">
      <div class="info-label">Battery Left:</div>
      <div id="batteryLeft">-</div>
    </div>
    <div class="info-item">
      <div class="info-label">Battery Right:</div>
      <div id="batteryRight">-</div>
    </div>
    <div class="info-item">
      <div class="info-label">Battery Case:</div>
      <div id="batteryCase">-</div>
    </div>
    <div class="info-item">
      <div class="info-label">ANC Status:</div>
      <div id="ancStatus">-</div>
    </div>
  </div>
</div>

<div class="container">
  <h3>Device Controls</h3>
  <div class="controls">
    <button onclick="sendBattery()" id="batteryBtn" disabled>Read Battery</button>
    <button onclick="getEQ()" id="eqBtn" disabled>Read EQ</button>
    <button onclick="getEQValues()" id="eqValuesBtn" disabled>Read EQ Values</button>
    <button onclick="sendANCread()" id="ancBtn" disabled>Read ANC</button>
    <button onclick="getFirmware()" id="firmwareBtn" disabled>Read Firmware</button>
    <button onclick="ringBuds(true)" id="ringBtn" disabled>Ring Buds</button>
    <button onclick="ringBuds(false)" id="stopRingBtn" disabled>Stop Ring</button>
  </div>
</div>

<div class="container">
  <h3>Communication Log</h3>
  <button onclick="clearLog()">Clear Log</button>
  <button onclick="toggleDebug()" id="debugBtn">Enable Debug</button>
  <div class="log" id="log"></div>
</div>

<script>
// Bluetooth SPP Communication Code
let SPPsocket = null;
let writeQueue = Promise.resolve();

let modelSpecs = {};
let modelBase = "";

let firmwareVersion = "";
let firmwareConfig = {};

let operationID = 0;
let operationList = {};

let debug = false;
let originalConsoleLog = console.log;

function log(msg) {
  const logElement = document.getElementById("log");
  const timestamp = new Date().toLocaleTimeString();
  logElement.textContent += `[${timestamp}] ${msg}\n`;
  logElement.scrollTop = logElement.scrollHeight;
  originalConsoleLog(msg);
}

function toggleDebug() {
  debug = !debug;
  const debugBtn = document.getElementById("debugBtn");
  if (debug) {
    console.log = originalConsoleLog;
    debugBtn.textContent = "Disable Debug";
    log("Debug mode enabled");
  } else {
    console.log = function () { };
    debugBtn.textContent = "Enable Debug";
    log("Debug mode disabled");
  }
}

function clearLog() {
  document.getElementById("log").textContent = "";
}

function updateStatus(connected) {
  const statusElement = document.getElementById("status");
  const connectBtn = document.getElementById("connectBtn");
  const disconnectBtn = document.getElementById("disconnectBtn");
  const initBtn = document.getElementById("initBtn");
  const batteryBtn = document.getElementById("batteryBtn");
  const eqBtn = document.getElementById("eqBtn");
  const eqValuesBtn = document.getElementById("eqValuesBtn");
  const ancBtn = document.getElementById("ancBtn");
  const firmwareBtn = document.getElementById("firmwareBtn");
  const ringBtn = document.getElementById("ringBtn");
  const stopRingBtn = document.getElementById("stopRingBtn");

  if (connected) {
    statusElement.textContent = "Connected";
    statusElement.className = "status connected";
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    initBtn.disabled = false;
    batteryBtn.disabled = false;
    eqBtn.disabled = false;
    eqValuesBtn.disabled = false;
    ancBtn.disabled = false;
    firmwareBtn.disabled = false;
    ringBtn.disabled = false;
    stopRingBtn.disabled = false;
  } else {
    statusElement.textContent = "Disconnected";
    statusElement.className = "status disconnected";
    connectBtn.disabled = false;
    disconnectBtn.disabled = true;
    initBtn.disabled = true;
    batteryBtn.disabled = true;
    eqBtn.disabled = true;
    eqValuesBtn.disabled = true;
    ancBtn.disabled = true;
    firmwareBtn.disabled = true;
    ringBtn.disabled = true;
    stopRingBtn.disabled = true;
  }
}

// UI Update Functions
function setFirmwareText(version) {
  document.getElementById("firmwareVersion").textContent = version;
  log(`Firmware version: ${version}`);
}

function setBattery(side, level, isCharging = false) {
  const elementMap = {
    'l': 'batteryLeft',
    'r': 'batteryRight',
    'c': 'batteryCase',
    's': 'batteryLeft' // stereo mode uses left display
  };

  if (elementMap[side]) {
    const chargingIndicator = isCharging ? ' 🔋' : '';
    document.getElementById(elementMap[side]).textContent = `${level}%${chargingIndicator}`;
  }
}

function setANCStatus(level) {
  const ancNames = {
    1: "ANC Level 1",
    2: "ANC Level 2",
    3: "ANC Level 3",
    4: "ANC Level 4",
    5: "ANC Level 5",
    6: "ANC Level 6"
  };
  document.getElementById("ancStatus").textContent = ancNames[level] || `Level ${level}`;
}

function setEQfromRead(mode) {
  log(`EQ Mode: ${mode}`);
}

function setInEarCheckbox(status) {
  log(`In-ear status: ${status}`);
}

function setLatencyModeCheckbox(status) {
  log(`Latency mode: ${status}`);
}

function setPersonalAncCheckbox(status) {
  log(`Personal ANC: ${status}`);
}

function setBassEnhance(enabled) {
  log(`Bass enhance: ${enabled ? 'enabled' : 'disabled'}`);
}

function setBassLevel(level) {
  log(`Bass level: ${level}`);
}

function setCustomEQ(levels) {
  log(`Custom EQ levels: ${levels.join(', ')}`);
}

function getCaseColor(colors) {
  log(`Case colors: ${colors.join(', ')}`);
}

function earTipStateStatus(left, right) {
  log(`Ear tip test - Left: ${left}, Right: ${right}`);
}

function updateGesturesFromArray(gestures) {
  log(`Gestures: ${JSON.stringify(gestures)}`);
}

async function send(command, payload = [], operation = "") {
    let header = [0x55, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    operationID++;
    header[7] = operationID;
    let commandBytes = new Uint8Array(new Uint16Array([command]).buffer);
    header[3] = commandBytes[0];
    header[4] = commandBytes[1];
    let payloadLength = payload.length;
    header[5] = payloadLength;
    header.push(...payload);
    let byteArray = new Uint8Array(header);
    let crc = crc16(byteArray);
    byteArray = [...byteArray, crc & 0xFF, crc >> 8];
    if (operation !== "") {
        operationList[operationID] = operation;
    }
    console.log("sending " + byteArray.map(byte => byte.toString(16).padStart(2, '0')).join(''));
    writeQueue = writeQueue.then(async () => {
        let writer = null;
        try {
            writer = await SPPsocket.writable.getWriter();
            console.log("Writing to SPPsocket: " + byteArray.map(byte => byte.toString(16).padStart(2, '0')).join(''));
            await writer.write(new Uint8Array(byteArray));
            log(`Sent: ${byteArray.map(byte => byte.toString(16).padStart(2, '0')).join('')}`);
        } catch (error) {
            console.error('Write failed:', error);
            log(`Write failed: ${error}`);
        } finally {
            if (writer) {
                await writer.close();
            }
        }
    });
}

function crc16(buffer) {
    let crc = 0xFFFF;
    for (let i = 0; i < buffer.length; i++) {
        crc ^= buffer[i];
        for (let j = 0; j < 8; j++) {
            crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);
        }
    }
    return crc;
}

async function initDevice() {
    log("Initializing device...");
    sendBattery();
    await new Promise(resolve => setTimeout(resolve, 100));
    getEQ();
    await new Promise(resolve => setTimeout(resolve, 100));
    getListeningMode();
    await new Promise(resolve => setTimeout(resolve, 100));
    getFirmware();
    await new Promise(resolve => setTimeout(resolve, 100));
    sendUTCtime();
    await new Promise(resolve => setTimeout(resolve, 100));
    sendInEarRead();
    await new Promise(resolve => setTimeout(resolve, 100));
    sendLatencyModeRead();
    await new Promise(resolve => setTimeout(resolve, 100));
    getPersonalizedANCStatus();
    await new Promise(resolve => setTimeout(resolve, 100));
    sendGetGesture();
    await new Promise(resolve => setTimeout(resolve, 100));
    sendANCread();
    await new Promise(resolve => setTimeout(resolve, 100));
    getAdvancedEQ();
    await new Promise(resolve => setTimeout(resolve, 100));
    get_enhanced_bass();
    await new Promise(resolve => setTimeout(resolve, 100));
    log("Device initialization complete");
}

async function updateBudsInfo(imageOnly = false, isHeadphone = false) {
    // Check for previously opened ports and try to reconnect
    const portsOpened = await navigator.serial.getPorts();
    for (const port of portsOpened) {
        log(`Found previously connected port: ${JSON.stringify(port.getInfo())}`);
        if (port.getInfo().bluetoothServiceClassId === "aeac4a03-dff5-498f-843a-34487cf133eb") {
            try {
                log("Attempting to reconnect to previously paired device...");
                await connectSPP(port);
                log("Successfully reconnected to previously paired device.");
                return;
            } catch (error) {
                log(`Reconnection failed: ${error}`);
            }
        }
    }

    if (!imageOnly) {
        log("No previously connected devices found. Use 'Connect' button to pair a new device.");
    }
}

function setModelBase() {
    modelSpecs = localStorage.getItem("model");
    //modelBase is a json string, so we need to parse it
    if (modelSpecs) {
        modelBase = JSON.parse(modelSpecs);
        modelBase = modelBase.base;
        document.getElementById("modelBase").textContent = modelBase;
    }
}

async function connectSPP(sppPort=null) {
    const SPP_UUID = "aeac4a03-dff5-498f-843a-34487cf133eb";
    const FASTPAIR_UUID = "df21fe2c-2515-4fdb-8886-f12c4d67927c";

    // Check if Web Serial API is supported
    if (!navigator.serial) {
        log("Error: Web Serial API is not supported in this browser. Please use Chrome, Edge, or another Chromium-based browser.");
        updateStatus(false);
        return;
    }

    try {
        log("Requesting Bluetooth SPP device...");

        if (sppPort === null) {
            sppPort = await navigator.serial.requestPort({
                allowedBluetoothServiceClassIds: [SPP_UUID],
                filters: [{ bluetoothServiceClassId: SPP_UUID }],
            });
        }

        if (sppPort) {
            log('Selected Bluetooth Serial Port Profile port: ' + JSON.stringify(sppPort.getInfo()));

            // Check if port is already open
            if (sppPort.readable || sppPort.writable) {
                log("Warning: Port appears to already be open. Attempting to close first...");
                try {
                    await sppPort.close();
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
                } catch (closeError) {
                    log(`Warning: Could not close port: ${closeError}`);
                }
            }

            log("Opening serial port with baudRate: 9600, bufferSize: 2048...");

            // Try opening with different configurations if the first fails
            const configs = [
                { baudRate: 9600, bufferSize: 2048 },
                { baudRate: 9600 },
                { baudRate: 115200, bufferSize: 2048 },
                { baudRate: 115200 }
            ];

            let opened = false;
            for (let i = 0; i < configs.length && !opened; i++) {
                try {
                    log(`Trying configuration ${i + 1}: ${JSON.stringify(configs[i])}`);
                    await sppPort.open(configs[i]);
                    opened = true;
                    log(`Successfully opened with configuration: ${JSON.stringify(configs[i])}`);
                } catch (openError) {
                    log(`Configuration ${i + 1} failed: ${openError}`);
                    if (i === configs.length - 1) {
                        throw openError; // Re-throw the last error
                    }
                }
            }

            setModelBase();
            SPPsocket = sppPort;
            updateStatus(true);

            //read from the serial port
            const reader = sppPort.readable.getReader();

            // Start reading in background
            readFromDevice(reader);

            log("Device connected successfully");
        } else {
            log("No port selected or port selection cancelled");
            updateStatus(false);
        }
    } catch (error) {
        let errorMessage = `Connection failed: ${error}`;

        // Provide more specific error messages
        if (error.name === 'NetworkError') {
            errorMessage += "\n\nPossible solutions:";
            errorMessage += "\n- Ensure the Bluetooth device is paired with your computer";
            errorMessage += "\n- Try disconnecting and reconnecting the Bluetooth device";
            errorMessage += "\n- Check if another application is using the device";
            errorMessage += "\n- Restart your browser and try again";
            errorMessage += "\n- Make sure the device supports Serial Port Profile (SPP)";
        } else if (error.name === 'NotFoundError') {
            errorMessage += "\n\nNo compatible Bluetooth SPP devices found. Make sure your device is:";
            errorMessage += "\n- Paired with your computer";
            errorMessage += "\n- Supports Serial Port Profile (SPP)";
            errorMessage += "\n- Not connected to another application";
        } else if (error.name === 'SecurityError') {
            errorMessage += "\n\nSecurity error. Try:";
            errorMessage += "\n- Using HTTPS (or localhost for local testing)";
            errorMessage += "\n- Checking browser permissions";
        }

        log(errorMessage);
        updateStatus(false);
    }
}

async function readFromDevice(reader) {
    try {
        while (SPPsocket && SPPsocket.readable) {
            const { value, done } = await reader.read();

            if (done) {
                reader.releaseLock();
                break;
            }

            //print hex string of the received data
            var string = "";
            for (let i = 0; i < value.length; i++) {
                //fill the string with leading zero if needed
                string += (value[i] < 16 ? "0" : "") + value[i].toString(16);
            }

            let rawData = new Uint8Array(value.buffer);
            //check if first byte is 0x55, else continue
            if (rawData[0] !== 85 || rawData.length < 8) {
                continue;
            }

            //header is 8 bytes long
            let header = rawData.slice(0, 6);
            let command = getCommand(header);
            console.log("Received command:", command);
            log(`Received: ${string} (Command: ${command})`);

            if (command === 57345 || command===16391) {
                readBattery(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 57347) {
                readANC(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16452) {
                readCustomEQ(rawData);
            }
            if (command === 16415 || command === 16464) {
                readEQ(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16450) {
                readFirmware(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 57357) {
                readEarFitTestResult(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16416) {
                readPersonalizedANC(rawData);
            }
            if (command === 16398) {
                readInEar(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16449) {
                readLatency(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16407) {
                readLEDCaseColor(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16408) {
                readGesture(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16414) {
                readANC(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16460) {
                read_advanced_eq_status( rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16462) {
                read_enhanced_bass(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }
            if (command === 16461) {
                readEQValues(rawData.reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), ''));
            }

            if (operationID >= 250) {
                operationID = 1;
                operationList = {};
            }
        }
    } catch (error) {
        log(`Read error: ${error}`);
        updateStatus(false);
    }
}

async function disconnectDevice() {
    if (SPPsocket) {
        try {
            log("Disconnecting device...");

            // Close any active readers first
            if (SPPsocket.readable && SPPsocket.readable.locked) {
                try {
                    const reader = SPPsocket.readable.getReader();
                    await reader.cancel();
                    reader.releaseLock();
                } catch (readerError) {
                    log(`Warning: Error releasing reader: ${readerError}`);
                }
            }

            // Close any active writers
            if (SPPsocket.writable && SPPsocket.writable.locked) {
                try {
                    const writer = SPPsocket.writable.getWriter();
                    await writer.close();
                } catch (writerError) {
                    log(`Warning: Error closing writer: ${writerError}`);
                }
            }

            await SPPsocket.close();
            SPPsocket = null;
            updateStatus(false);
            log("Device disconnected successfully");
        } catch (error) {
            log(`Disconnect error: ${error}`);
            // Force cleanup even if close fails
            SPPsocket = null;
            updateStatus(false);
        }
    } else {
        log("No device to disconnect");
        updateStatus(false);
    }
}

function sendBattery() {
    send(49159, [], "readBattery");
}

function readBattery(hexString) {
    let connectedDevices = 0;
    let batteryStatus = { "left": "DISCONNECTED", "right": "DISCONNECTED", "case": "DISCONNECTED", "stereo": "DISCONNECTED" };
    let deviceIdToKey = { 0x02: "left", 0x03: "right", 0x04: "case", 0x06: "stereo" };
    let BATTERY_MASK = 127;
    let RECHARGING_MASK = 128;

    let hexArray = hexString.match(/.{2}/g).map(byte => parseInt(byte, 16));

    connectedDevices = hexArray[8];
    for (let i = 0; i < connectedDevices; i++) {
        let deviceId = hexArray[9 + (i * 2)];
        let key = deviceIdToKey[deviceId] || "DISCONNECTED";
        let batteryLevel = hexArray[10 + (i * 2)] & BATTERY_MASK;
        let isCharging = (hexArray[10 + (i * 2)] & RECHARGING_MASK) === RECHARGING_MASK;
        batteryStatus[key] = {
            "batteryLevel": batteryLevel,
            "isCharging": isCharging
        };
    }

    let batteryLeft = batteryStatus["left"]["batteryLevel"];
    let batteryRight = batteryStatus["right"]["batteryLevel"];
    let batteryCase = batteryStatus["case"]["batteryLevel"];
    let batteryStereo = batteryStatus["stereo"]["batteryLevel"];

    console.log("Battery status:", batteryStatus);

    if (batteryStatus["stereo"] !== "DISCONNECTED") {
        setBattery("s", batteryStereo, batteryStatus["stereo"]["isCharging"])
    }
    else {
        setBattery("l", batteryLeft, batteryStatus["left"]["isCharging"])
        setBattery("r", batteryRight, batteryStatus["right"]["isCharging"])
        setBattery("c", batteryCase, batteryStatus["case"]["isCharging"])
    }
}

function getCommand(header) {
    console.log("header " + header)
    let commandBytes = new Uint8Array(header.slice(3, 5));
    console.log( "commandBytes: " + commandBytes)
    let commandInt = new Uint16Array(commandBytes.buffer)[0];
    console.log ("commandInt: " + commandInt);
    return commandInt;
}

function readANC(hexString) {
    console.log("readANC called");
    let hexArray = hexString.match(/.{2}/g).map(byte => parseInt(byte, 16));
    let ancStatus = hexArray[9];
    let level = 0;

    if (ancStatus === 5) {
        level = 1;
    } else if (ancStatus === 7) {
        level = 2;
    } else if (ancStatus === 3) {
        level = 3;
    } else if (ancStatus === 1) {
        level = 4;
    } else if (ancStatus === 2) {
        level = 5;
    } else if (ancStatus === 4) {
        level = 6;
    }
    console.log("ANC level " + level);
    setANCStatus(level);
}

function sendANCread() {
    var isAnc = firmwareVersion.split(".");
    if (modelBase === "B157" && isAnc[2] !== "2")
        return;
    send(49182, [], "readANC");
}

function read_advanced_eq_status(hexString) {
    console.log("read_advanced_eq_status called");
    let hexArray = hexString.match(/.{2}/g).map(byte => parseInt(byte, 16));
    let advancedStatus = hexArray[8];
    console.log("advancedEQ " + advancedStatus);
    if (modelBase === "B157" || modelBase === "B155" || modelBase === "B171" || modelBase === "B174" || modelBase === "B170") {
        if (advancedStatus === 1) {
            setEQfromRead(6);
        }
    }
}

function getEQ() {
    if (modelBase !== "B172" && modelBase !== "B168" && modelBase !== "B179" && modelBase !== "B184" && modelBase !== "B185") {
        send(49183, [], "readEQ");
    }
}

function getListeningMode() {
    if (modelBase === "B172" || modelBase === "B168" || modelBase === "B179" || modelBase === "B184" || modelBase === "B185") {
        send(49232, [], "readListeningMode");
    }
}

function readEQ(hexString) {
    console.log("readEQ called");
    let hexArray = hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16));
    let eqMode = hexArray[8];
    console.log("eqMode " + eqMode);
    setEQfromRead(eqMode);
}

function get_enhanced_bass() {
    if (modelBase === "B171" || modelBase === "B172" || modelBase === "B168" || modelBase === "B162" || modelBase === "B184" || modelBase === "B179" || modelBase === "B170") {
        send(49230, [], "readEnhancedBass");
    }
}

function read_enhanced_bass(hexString) {
    if (modelBase === "B171" || modelBase === "B172" || modelBase === "B168" || modelBase === "B162" || modelBase === "B184" || modelBase === "B179" || modelBase === "B170") {
        let hexArray = hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16));
        let enabled = hexArray[8];
        let level = hexArray[9];
        setBassEnhance(enabled);
        setBassLevel(level / 2);
    }
}

function getAdvancedEQ() {
    send(49228, [], "readAdvancedEQ");
}

async function getEQValues() {
    // Based on Java: GET_ADVANCE_CUSTOM_EQ_VALUE command with profile index payload
    // Loop through 8 PEQ filters (indices 0-7) as mentioned in the Java code
    log("Reading EQ Values for all 8 PEQ filters...");

    const payload = toByteArray(0, 0, 1);
    log(`Requesting EQ values`);
    send(49229, payload, `readEQValues`);
}

function createEQDataPacket(profileIndex, eqBands, totalGain = 0.0) {
    // Based on Java obtainDataPacket() method
    const numBands = eqBands ? eqBands.length : 0;
    const packetSize = 1 + 1 + 4 + (numBands * 13); // profileIndex + numBands + totalGain + (bands * 13 bytes each)

    const packet = new Uint8Array(packetSize);
    let offset = 0;

    // Profile index (1 byte)
    packet[offset++] = profileIndex;

    // Number of bands (1 byte)
    packet[offset++] = numBands;

    // Total gain (4 bytes as float, little-endian)
    const totalGainBytes = floatToBytes(totalGain);
    packet.set(totalGainBytes, offset);
    offset += 4;

    // EQ bands data
    if (eqBands) {
        for (const band of eqBands) {
            // Filter type (1 byte)
            packet[offset++] = band.filterType || 1; // Default to PEAK

            // Gain (4 bytes as float)
            const gainBytes = floatToBytes(band.gain || 0.0);
            packet.set(gainBytes, offset);
            offset += 4;

            // Frequency (4 bytes as float)
            const freqBytes = floatToBytes(band.frequency || 1000.0);
            packet.set(freqBytes, offset);
            offset += 4;

            // Quality (4 bytes as float)
            const qualityBytes = floatToBytes(band.quality || 0.707);
            packet.set(qualityBytes, offset);
            offset += 4;
        }
    }

    return packet;
}

function floatToBytes(value) {
    // Convert float to 4-byte array (little-endian)
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setFloat32(0, value, true); // true for little-endian
    return new Uint8Array(buffer);
}

// JavaScript equivalent of DataExtKt.toByteArray$default(i, 0, 1, (Object) null)
function toByteArray(value, offset = 0, length = 1) {
    // Convert integer to byte array with specified length
    const byteArray = new Uint8Array(length);

    if (length === 1) {
        // Single byte - just take the lower 8 bits
        byteArray[0] = value & 0xFF;
    } else if (length === 2) {
        // Two bytes - little-endian format
        byteArray[0] = value & 0xFF;
        byteArray[1] = (value >> 8) & 0xFF;
    } else if (length === 4) {
        // Four bytes - little-endian format
        byteArray[0] = value & 0xFF;
        byteArray[1] = (value >> 8) & 0xFF;
        byteArray[2] = (value >> 16) & 0xFF;
        byteArray[3] = (value >> 24) & 0xFF;
    } else {
        // Default: single byte
        byteArray[0] = value & 0xFF;
    }

    return Array.from(byteArray);
}

function readEQValues(hexString) {
    console.log("readEQValues called");

    // Enhanced decoder based on Java ByteBuffer structure:
    // ByteBuffer.allocate((size * 13) + 6);
    // - profileIndex (1 byte)
    // - size/numBands (1 byte)
    // - totalGain (4 bytes as float)
    // - For each band (13 bytes):
    //   - filterType (1 byte)
    //   - gain (4 bytes as float)
    //   - frequency (4 bytes as float)
    //   - quality (4 bytes as float)

    let hexArray = hexString.match(/.{2}/g).map(byte => parseInt(byte, 16));

    if (hexArray.length < 10) {
        log("EQ Values response too short");
        return;
    }

    // Log raw hex data for debugging
    log(`Raw EQ Values hex: ${hexString}`);
    log(`Hex array length: ${hexArray.length} bytes`);

    let offset = 8; // Skip 8-byte protocol header

    // Profile index (1 byte) - this represents the filter index (0-7)
    const profileIndex = hexArray[offset++];

    // Number of bands/size (1 byte)
    const numBands = hexArray[offset++];

    // Total gain (4 bytes as float, little-endian as per DataExtKt.toByteArray)
    const totalGainBytes = hexArray.slice(offset, offset + 4);
    const totalGain = bytesToFloat(totalGainBytes);
    offset += 4;

    // Calculate expected packet size based on Java: (size * 13) + 6
    const expectedSize = (numBands * 13) + 6;
    const actualDataSize = hexArray.length - 8; // Minus protocol header

    log(`=== EQ VALUES DECODER ===`);
    log(`Profile Index: ${profileIndex}`);
    log(`Number of Bands: ${numBands}`);
    log(`Total Gain: ${totalGain.toFixed(4)}dB`);
    log(`Expected data size: ${expectedSize} bytes, Actual: ${actualDataSize} bytes`);
    log(`Parsing ${numBands} EQ bands...`);

    const eqBands = [];

    // Parse each EQ band (13 bytes each as per Java structure)
    for (let i = 0; i < numBands && offset + 12 < hexArray.length; i++) {
        log(`--- Band ${i + 1} (offset ${offset}) ---`);

        // Filter type (1 byte)
        const filterType = hexArray[offset++];

        // Gain (4 bytes as float)
        const gainBytes = hexArray.slice(offset, offset + 4);
        const gain = bytesToFloat(gainBytes);
        offset += 4;

        // Frequency (4 bytes as float)
        const freqBytes = hexArray.slice(offset, offset + 4);
        const frequency = bytesToFloat(freqBytes);
        offset += 4;

        // Quality (4 bytes as float)
        const qualityBytes = hexArray.slice(offset, offset + 4);
        const quality = bytesToFloat(qualityBytes);
        offset += 4;

        const band = {
            filterType: filterType,
            gain: gain,
            frequency: frequency,
            quality: quality
        };

        eqBands.push(band);

        // Enhanced filter type mapping
        const filterTypeNames = {
            0: "LOW_SHELF",
            1: "PEAK",
            2: "HIGH_SHELF"
        };
        const filterTypeName = filterTypeNames[filterType] || `UNKNOWN_TYPE_${filterType}`;

        // Detailed output as requested
        log(`FilterType: ${filterType} (${filterTypeName})`);
        log(`Gain: ${gain.toFixed(4)}dB`);
        log(`Frequency: ${frequency.toFixed(2)}Hz`);
        log(`Quality: ${quality.toFixed(4)}`);
        log(`Raw bytes - Type:[${filterType.toString(16).padStart(2,'0')}] Gain:[${gainBytes.map(b=>b.toString(16).padStart(2,'0')).join(' ')}] Freq:[${freqBytes.map(b=>b.toString(16).padStart(2,'0')).join(' ')}] Q:[${qualityBytes.map(b=>b.toString(16).padStart(2,'0')).join(' ')}]`);
    }

    // Summary output
    log(`=== SUMMARY ===`);
    log(`Decoded ${eqBands.length} EQ bands for profile ${profileIndex}`);
    eqBands.forEach((band, idx) => {
        const filterTypeName = { 0: "LOW_SHELF", 1: "PEAK", 2: "HIGH_SHELF" }[band.filterType] || `TYPE_${band.filterType}`;
        log(`Band ${idx + 1}: ${filterTypeName} | ${band.frequency.toFixed(1)}Hz | ${band.gain.toFixed(2)}dB | Q=${band.quality.toFixed(3)}`);
    });

    // Initialize the array if it doesn't exist
    if (!window.allEQValues) {
        window.allEQValues = [];
    }

    // Store the EQ values for this specific filter index
    window.allEQValues[profileIndex] = {
        profileIndex: profileIndex,
        totalGain: totalGain,
        bands: eqBands,
        rawHex: hexString
    };

    // Also keep the legacy single response for compatibility
    window.currentEQValues = {
        profileIndex: profileIndex,
        totalGain: totalGain,
        bands: eqBands,
        rawHex: hexString
    };

    log(`Stored EQ values for profile ${profileIndex}`);
}

function bytesToFloat(byteArray) {
    // Convert 4-byte array to float (little-endian)
    const buffer = new ArrayBuffer(4);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < 4; i++) {
        view[i] = byteArray[i];
    }
    const dataView = new DataView(buffer);
    return dataView.getFloat32(0, true); // true for little-endian
}

function readCustomEQ(hexString) {
    console.log("readCustomEQ called");
    if (modelBase !== "B181") {
        console.log(hexString);
        var level = [];
        for (var i = 0; i < 3; i++) {
            var array = [];
            for (var j = 0; j < 4; j++) {
                array.push(hexString[14 + (i * 13) + j]);
            }
            level.push(fromFormatFloatForEQ(array));
        }
        level.forEach(function (element) {
            console.log(element);
        });
        var formatedArray = [level[2], level[0], level[1]];
        setCustomEQ(formatedArray);
    }
}

function fromFormatFloatForEQ(array) {
    for (let i = 0; i < Math.floor(array.length / 2); i++) {
        let j = array.length - i - 1;
        [array[i], array[j]] = [array[j], array[i]];
    }
    if (array[0] === 0 && array[1] === 0 && array[2] === 0 && (array[3] & 0x80)) {
        array[3] = array[3] & 0x7f;
        let buffer = new ArrayBuffer(array.length);
        let view = new Uint8Array(buffer);
        for (let i = 0; i < array.length; i++) {
            view[i] = array[i];
        }
        let f = new DataView(buffer).getFloat32(0, false);
        return -f;
    } else {
        let buffer = new ArrayBuffer(array.length);
        let view = new Uint8Array(buffer);
        for (let i = 0; i < array.length; i++) {
            view[i] = array[i];
        }
        let f = new DataView(buffer).getFloat32(0, false);
        return f;
    }
}

function ringBuds(isRing, isLeft = false) {
    let byteArray = [0x00];
    if (modelBase === "B181") {
        if (isRing) {
            byteArray[0] = 0x01;
        } else {
            byteArray[0] = 0x00;
        }
    } else if (modelBase === "B170") {
        byteArray = [0x06, 0x00];
        if (isRing) {
            byteArray[1] = 0x01;
        } else {
            byteArray[1] = 0x00;
        }
    } else if (modelBase !== "B181") {
        byteArray = [0x00, 0x00];
        if (isLeft) {
            byteArray[0] = 0x02;
        } else {
            byteArray[0] = 0x03;
        }
        if (isRing) {
            byteArray[1] = 0x01;
        }
    }
    send(61442, byteArray);
}

function getFirmware() {
    send(49218, [], "readFirmware");
}

function readFirmware(hexstring) {
    let hexArray = new Uint8Array(hexstring.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    let size = hexArray[5];
    firmwareVersion = "";
    for (let i = 0; i < size; i++) {
        firmwareVersion += String.fromCharCode(hexArray[8 + i]);
    }
    setFirmwareText(firmwareVersion);
}

function readEarFitTestResult(hexstring) {
    hexstring = new Uint8Array(hexstring.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    let LeftearFitTestResult = hexstring[8];
    let RightearFitTestResult = hexstring[9];
    earTipStateStatus(LeftearFitTestResult, RightearFitTestResult);
}

function sendInEarRead() {
    if (modelBase !== "B174") {
        send(49166, [], "readInEar");
    }
}

function sendLatencyModeRead() {
    send(49217, [], "readLatency");
}

function readInEar(hexString) {
    console.log("readInEar called");
    hexString = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    inEarStatus = hexString[10];
    setInEarCheckbox(inEarStatus);
}

function readLatency(hexString) {
    console.log("readLatency called");
    hexString = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    latencyStatus = hexString[8];
    setLatencyModeCheckbox(latencyStatus);
}

function getPersonalizedANCStatus() {
    if (modelBase === "B155") {
        send(49184, [], "readPersonalizedANC");
    }
}

function readPersonalizedANC(hexString) {
    personalizedANCStatus = hexString[8];
    setPersonalAncCheckbox(personalizedANCStatus);
}

function sendUTCtime() {
    var date = new Date();
    var secEpoch = Math.floor(date.getTime() / 1000);
    //long to 4 bytes
    var byteArray = new Uint8Array(4);
    byteArray[0] = (secEpoch >> 24) & 0xFF;
    byteArray[1] = (secEpoch >> 16) & 0xFF;
    byteArray[2] = (secEpoch >> 8) & 0xFF;
    byteArray[3] = secEpoch & 0xFF;
    console.log("Sending UTC time: " + byteArray.map(byte => byte.toString(16).padStart(2, '0')).join(''));
    send(61450, byteArray, "setUTCtime");
}

function sendGetGesture() {
    send(49176, [], "getGesture");
}

function readGesture(hexString) {
    console.log("readGesture called");
    hexString = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

    console.log(Array.from(hexString, byte => byte.toString(16)).join(""));
    var gestureCount = hexString[8];

    var gestureArray = [];
    for (var i = 0; i < gestureCount; i++) {
        var gesture = {};
        gesture["gestureDevice"] = hexString[9 + i * 4];
        gesture["gestureCommon"] = hexString[10 + i * 4];
        gesture["gestureType"] = hexString[11 + i * 4];
        gesture["gestureAction"] = hexString[12 + i * 4];
        gestureArray.push(gesture);
    }
    console.log(gestureArray);
    updateGesturesFromArray(gestureArray);
}

function readLEDCaseColor(hexString) {
    if (modelBase === "B181") {
        console.log("readLEDCaseColor called");
        const hexArray = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
        const numberOfLed = hexArray[8];
        console.log(hexArray.map(byte => byte.toString(16).padStart(2, '0')).join(''));
        const ledArray = [];
        for (let i = 0; i < numberOfLed; i++) {
            ledArray.push([
                hexArray[10 + (i * 4)],
                hexArray[11 + (i * 4)],
                hexArray[12 + (i * 4)]
            ]);
        }
        const ledArrayString = ledArray.map(led => `#${led.map(value => value.toString(16).padStart(2, '0')).join('')}`);
        getCaseColor([ledArrayString[2], ledArrayString[1], ledArrayString[0], ledArrayString[3], ledArrayString[4]]);
    }
}

// Browser compatibility check
function checkBrowserCompatibility() {
    const compatibilityInfo = [];

    // Check Web Serial API support
    if (!navigator.serial) {
        compatibilityInfo.push("❌ Web Serial API not supported");
        compatibilityInfo.push("   Please use Chrome 89+, Edge 89+, or another Chromium-based browser");
    } else {
        compatibilityInfo.push("✅ Web Serial API supported");
    }

    // Check if running on HTTPS or localhost
    const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    if (!isSecure) {
        compatibilityInfo.push("⚠️  Not running on HTTPS or localhost");
        compatibilityInfo.push("   Some features may not work properly");
    } else {
        compatibilityInfo.push("✅ Running on secure connection");
    }

    // Check user agent for known compatible browsers
    const userAgent = navigator.userAgent;
    const isChrome = userAgent.includes('Chrome') && !userAgent.includes('Edg');
    const isEdge = userAgent.includes('Edg');
    const isOpera = userAgent.includes('OPR');

    if (isChrome || isEdge || isOpera) {
        compatibilityInfo.push("✅ Compatible browser detected");
    } else {
        compatibilityInfo.push("⚠️  Browser compatibility uncertain");
        compatibilityInfo.push("   For best results, use Chrome, Edge, or Opera");
    }

    // Log compatibility information
    log("Browser Compatibility Check:");
    compatibilityInfo.forEach(info => log(info));
    log(""); // Empty line for spacing

    return navigator.serial && isSecure;
}

// Initialize the page
updateStatus(false);
if (!debug) {
    console.log = function () { };
}

// Run compatibility check on page load
window.addEventListener('load', () => {
    const isCompatible = checkBrowserCompatibility();
    if (!isCompatible) {
        log("⚠️  Some compatibility issues detected. Connection may fail.");
        log("For best results, use Chrome or Edge on HTTPS or localhost.");
        log("");
    }
});

</script>

</body>
</html>
