<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Device PEQ Plugin Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      padding: 20px;
    }

    .peq-container {
      border: 1px solid #ccc;
      padding: 15px;
      max-width: 500px;
      margin-bottom: 20px;
      background-color: #f9f9f9;
    }

    .peq-container h3 {
      margin-top: 0;
    }

    .filter-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .filter-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .peq-controls {
      margin-top: 10px;
    }

    button {
      margin-top: 10px;
      padding: 5px 10px;
      cursor: pointer;
    }

  </style>
</head>
<body>

<h2>CrinGraph 'Plugin' devicePEQ Test Page</h2>

<div class="peq-container">
  <h3>Filters</h3>
  <div id="filter-list" class="filter-list">
    <div class="filter-item">
      <label>Type:</label>
      <select class="filter-type">
        <option value="PK">Peak</option>
        <option value="LSQ">Low Shelf</option>
        <option value="HSQ">High Shelf</option>
      </select>
      <label>Freq:</label> <input type="number" class="filter-freq" value="100">
      <label>Gain:</label> <input type="number" class="filter-gain" value="-3">
      <label>Q:</label> <input type="number" class="filter-q" value="0.707">
    </div>
    <div class="filter-item">
      <label>Type:</label>
      <select class="filter-type">
        <option value="PK">Peak</option>
        <option value="LSQ">Low Shelf</option>
        <option value="HSQ">High Shelf</option>
      </select>
      <label>Freq:</label> <input type="number" class="filter-freq" value="1000">
      <label>Gain:</label> <input type="number" class="filter-gain" value="1">
      <label>Q:</label> <input type="number" class="filter-q" value="1.0">
    </div>
    <div class="filter-item">
      <label>Type:</label>
      <select class="filter-type">
        <option value="PK">Peak</option>
        <option value="LSQ">Low Shelf</option>
        <option value="HSQ">High Shelf</option>
      </select>
      <label>Freq:</label> <input type="number" class="filter-freq" value="2000">
      <label>Gain:</label> <input type="number" class="filter-gain" value="3">
      <label>Q:</label> <input type="number" class="filter-q" value="0.707">
    </div>
  </div>
  <div class="peq-controls">
    <button onclick="addFilter()">Add Filter</button>
    <button onclick="clearFilters()">Clear Filters</button>
  </div>
</div>

<div class="extra-eq">
  <button id="btnLoadFR">Load FR...</button>
  <input type="file" id="frFileInput" accept=".txt" style="display:none;">
  <button id="btnLoadTargetFR">Load Target FR...</button>
  <input type="file" id="targetFRFileInput" accept=".txt" style="display:none;">
</div>

<script>
  // Global phoneObj holds the loaded FR data for plugins
  const phoneObj = {
    rawChannels: []  // Array of {freq, spl, phase} objects
  }
  const targetObj = {
    rawChannels: []  // Array of {freq, spl, phase} objects
  };

  window.phoneObj = phoneObj;
  // Helper: ensure default flat FR if none loaded
  function ensureDefaultFRIntoPhone() {
    if (phoneObj.rawChannels && phoneObj.rawChannels.length) return;
    const points = 256;
    const fMin = 20, fMax = 20000;
    const logMin = Math.log10(fMin), logMax = Math.log10(fMax);
    phoneObj.rawChannels = [];
    for (let i = 0; i < points; i++) {
      const t = i / (points - 1);
      const f = Math.pow(10, logMin + t * (logMax - logMin));
      phoneObj.rawChannels.push({ freq: f, spl: 0, phase: 0 });
    }
  }

  // Parse FR .txt file (expects header row then f spl phase columns)
  function parseFRTextIntoPhone(text) {
    try {
      const lines = text.trim().split(/\r?\n/);
      const rawChannels = [];
      for (let line of lines.slice(1)) {
        const parts = line.trim().split(/\s+/).map(Number);
        if (parts.length >= 2 && !Number.isNaN(parts[0]) && !Number.isNaN(parts[1])) {
          rawChannels.push({
            freq: parts[0],
            spl: parts[1],
            phase: (parts.length >= 3 && !Number.isNaN(parts[2])) ? parts[2] : 0
          });
        }
      }
      if (rawChannels.length) {
        phoneObj.rawChannels = rawChannels;
        console.log('FR loaded into phoneObj:', { points: rawChannels.length });
        document.dispatchEvent(new CustomEvent('PhoneFRLoaded'));
      } else {
        console.warn('FR file parsed but no usable rows found');
      }
    } catch (e) {
      console.error('Failed parsing FR file:', e);
    }
  }

  // Wire up FR loader UI
  const btnLoadFR = document.getElementById('btnLoadFR');
  const frInput = document.getElementById('frFileInput');
  if (btnLoadFR && frInput) {
    btnLoadFR.addEventListener('click', () => frInput.click());
    frInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => parseFRTextIntoPhone(ev.target.result);
      reader.readAsText(file);
      // Reset input so selecting same file again triggers change
      e.target.value = '';
    });
  }

  // Parse Target FR .txt file
  function parseTargetFRTextIntoPhone(text) {
    try {
      const lines = text.trim().split(/\r?\n/);
      const rawChannels = [];
      for (let line of lines.slice(1)) {
        const parts = line.trim().split(/\s+/).map(Number);
        if (parts.length >= 2 && !Number.isNaN(parts[0]) && !Number.isNaN(parts[1])) {
          rawChannels.push({
            freq: parts[0],
            spl: parts[1],
            phase: 0  // Target usually doesn't have phase
          });
        }
      }
      if (rawChannels.length) {
        targetObj.rawChannels = rawChannels;
        console.log('Target FR loaded into targetObj:', { points: rawChannels.length });
        document.dispatchEvent(new CustomEvent('TargetFRLoaded'));
      } else {
        console.warn('Target FR file parsed but no usable rows found');
      }
    } catch (e) {
      console.error('Failed parsing Target FR file:', e);
    }
  }

  // Wire up Target FR loader UI
  const btnLoadTargetFR = document.getElementById('btnLoadTargetFR');
  const targetFRInput = document.getElementById('targetFRFileInput');
  if (btnLoadTargetFR && targetFRInput) {
    btnLoadTargetFR.addEventListener('click', () => targetFRInput.click());
    targetFRInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => parseTargetFRTextIntoPhone(ev.target.result);
      reader.readAsText(file);
      // Reset input so selecting same file again triggers change
      e.target.value = '';
    });
  }

  // Wire up Normalize FR input
  const normalizeFRInput = document.getElementById('normalizeFRInput');
  if (normalizeFRInput) {
    normalizeFRInput.addEventListener('input', () => {
      const value = parseFloat(normalizeFRInput.value);
      phoneObj.normalizeFRFreq = (!isNaN(value) && value >= 20 && value <= 20000) ? value : null;
      console.log('Normalize FR frequency set to:', phoneObj.normalizeFRFreq);
      document.dispatchEvent(new CustomEvent('NormalizeFRChanged'));
    });
  }
  // Mock function to populate PEQ fields from device settings
  function filtersToElem(filters) {
    console.log("Applying filters from device:", filters);
    const filterList = document.getElementById("filter-list");
    filterList.innerHTML = ""; // Clear existing filters
    filters.forEach(filter => {
      const filterItem = document.createElement("div");
      filterItem.className = "filter-item";
      // Set default filter type to "PK" if not provided
      const filterType = filter.type || "PK";
      filterItem.innerHTML = `
                    <label>Type:</label>
                    <select class="filter-type">
                      <option value="PK" ${filterType === "PK" ? "selected" : ""}>Peak</option>
                      <option value="LSQ" ${filterType === "LSQ" ? "selected" : ""}>Low Shelf</option>
                      <option value="HSQ" ${filterType === "HSQ" ? "selected" : ""}>High Shelf</option>
                    </select>
                    <label>Freq:</label> <input type="number" class="filter-freq" value="${filter.freq}">
                    <label>Gain:</label> <input type="number" class="filter-gain" value="${filter.gain}">
                    <label>Q:</label> <input type="number" class="filter-q" value="${filter.q}">
                `;
      filterList.appendChild(filterItem);
    });
  }

  // Mock function to extract filters from UI for pushing to the device
  function elemToFilters(includeDisabled) {
    const filterElems = document.querySelectorAll(".filter-item");
    const filters = Array.from(filterElems).map(elem => ({
      type: elem.querySelector(".filter-type").value,
      freq: parseFloat(elem.querySelector(".filter-freq").value),
      gain: parseFloat(elem.querySelector(".filter-gain").value),
      q: parseFloat(elem.querySelector(".filter-q").value),
      disabled: false, // Can be extended to support enabling/disabling
    }));
    console.log("Extracted filters:", filters);
    return filters;
  }

  // Mock function to calculate the preamp gain from the filters
  function calcEqDevPreamp(filters) {
    const maxGain = Math.max(...filters.map(f => f.gain));
    console.log("Calculated Preamp Gain:", -maxGain);
    if (maxGain < 0) return 0;  //
    return -maxGain; // Simple logic to avoid clipping
  }

  // Mock function to apply the EQ
  function applyEQ() {

  }

  let norm_fr = 1000;
  let getCurrentPhoneTargetNormalisation = () => {

    return {
      phoneObj,
      targetObj,
      norm_fr
    };
  }

    // Utility function to add a new filter entry
  function addFilter() {
    const filterList = document.getElementById("filter-list");
    const filterItem = document.createElement("div");
    filterItem.className = "filter-item";
    filterItem.innerHTML = `
                <label>Type:</label>
                <select class="filter-type">
                  <option value="PK" selected>Peak</option>
                  <option value="LSQ">Low Shelf</option>
                  <option value="HSQ">High Shelf</option>
                </select>
                <label>Freq:</label> <input type="number" class="filter-freq" value="1000">
                <label>Gain:</label> <input type="number" class="filter-gain" value="0">
                <label>Q:</label> <input type="number" class="filter-q" value="0.707">
            `;
    filterList.appendChild(filterItem);
  }

  // Utility function to clear all filters
  function clearFilters() {
    document.getElementById("filter-list").innerHTML = "";
  }

      // Typically this should be put into the config.js in a Cringraph
      let extraEQplugins = [
        './devicePEQ/plugin.js', // Path to one or more "extraEQ" plugins
        './sharePEQ/plugin.js', // Path to one or more "extraEQ" plugins
        './visualizePEQ/plugin.js',  // Add the visualizePEQ plugin
        './subjectizePEQ/plugin.js'  // Add the subjectizePEQ plugin
      ];

      // ... existing code ...

      // Might come from the config.js
      let config = {
        advanced: true,
        showLogs: true,
        renderPEQ: {
          enabled: true,
          position: 'peq-controls',
          buttonText: 'PEQ Visualizer',
          buttonClass: 'renderPEQ-control-btn'
        }
      };

  /**
   * Dynamically load a plugin from a sub-folder passing it the useful context
   * @param pluginsToLoad
   * @param context
   * @returns {Promise<void>}
   */
  async function loadPlugins(pluginsToLoad, context) {
    for (const pluginPath of pluginsToLoad) {
      try {
        let initializePlugin;

        if (typeof module !== 'undefined' && module.exports) {
          // CommonJS environment (e.g., Node.js)
          initializePlugin = require(pluginPath);
        } else {
          // ES Module environment (e.g., modern browsers)
          const module = await import(pluginPath);
          initializePlugin = module.default;
        }

        // Call the plugin function with the provided context
        await initializePlugin(context);
        console.log(`Successfully loaded plugin: ${pluginPath}`);
      } catch (error) {
        console.error(`Error loading plugin ${pluginPath}:`, error.message);
      }
    }
  }

  // Ensure phoneObj has at least a flat FR before plugins use it
  ensureDefaultFRIntoPhone();

  // Load the plugin with the provided functions and phoneObj
  if (typeof extraEQplugins !== "undefined") {
    loadPlugins(extraEQplugins, {
      filtersToElem,  // Put Filters back to Html Elements
      elemToFilters,  // Get Filters from Html Elements
      calcEqDevPreamp,// Reuse existing gain calculations
      applyEQ,        // Apply EQ
      config,
      getCurrentPhoneTargetNormalisation
    });
  }

  // After plugins load, wire up the button to call openOverlay with phoneObj
  // This simulates how graphtool.js will call the plugin
  setTimeout(() => {
    const openPEQBtn = document.getElementById('openPEQOverlay');
    if (openPEQBtn && typeof window.renderPEQOpenOverlay === 'function') {
      // Override the button click to pass phoneObj directly
      openPEQBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();

        // targetObj already has rawChannels format - no conversion needed

        // Get alignment frequency from normalizeFRInput
        const alignFreq = phoneObj.normalizeFRFreq || null;

        // Optional: Define limits for gain and Q values (defaults: maxGain=12, minGain=-12, minQ=0.2, maxQ=10)
        const limits = {
          maxGain: 12,
          minGain: -12,
          minQ: 0.2,
          maxQ: 10
        };

        // Call the openOverlay method with the optional parameters
        window.renderPEQOpenOverlay(phoneObj, targetObj, alignFreq, limits);
      }, true); // Use capture phase to intercept before plugin's handler
    }
  }, 500); // Wait for plugin to initialize

  // On load: check URL for F/T/G/Q/D params and auto-add that many filters for testing
  (function autoAddFiltersFromUrl(){
    try {
      const params = new URLSearchParams(window.location.search || '');
      let maxIndex = 0;
      for (const key of params.keys()) {
        // Match F1/T2/G10/Q3/D4 etc.
        const m = /^([FTGQD])(\d+)$/.exec(key);
        if (m) {
          const idx = parseInt(m[2], 10);
          if (!isNaN(idx)) maxIndex = Math.max(maxIndex, idx);
        }
      }
      if (maxIndex > 0) {
        const list = document.getElementById('filter-list');
        const current = (list && list.querySelectorAll('.filter-item').length) || 0;
        for (let i = current; i < maxIndex; i++) {
          addFilter();
        }
        // Optionally, we could populate values here, but requirement only asks to add rows.
        // Fire an event similar to what plugins might listen to, for consistency.
        try { document.dispatchEvent(new CustomEvent('UpdateExtensionFilters')); } catch(_) {}
      }
    } catch(e) {
      console.warn('Auto-add filters from URL failed:', e);
    }
  })();
</script>

</body>
</html>
